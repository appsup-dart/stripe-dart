{"name":"Invoice","qualifiedName":"stripe/stripe.Invoice","comment":"<p>Invoices are statements of what a customer owes for a particular billing\nperiod, including subscriptions, invoice items, and any automatic proration\nadjustments if necessary.</p>\n<p>Once an invoice is created, payment is automatically attempted. Note that the\npayment, while automatic, does not happen exactly at the time of invoice\ncreation. If you have configured webhooks, the invoice will wait until one\nhour after the last webhook is successfully sent\n(or the last webhook times out after failing).</p>\n<p>Any customer credit on the account is applied before determining how much is\ndue for that invoice (the amount that will be actually charged). If the\namount due for the invoice is less than 50 cents (the minimum for a charge),\nwe add the amount to the customer's running account balance to be added to\nthe next invoice. If this amount is negative, it will act as a credit to\noffset the next invoice. Note that the customer account balance does not\ninclude unpaid invoices; it only includes balances that need to be taken\ninto account when calculating the amount due for the next invoice.</p>","isAbstract":false,"superclass":"stripe/stripe.ApiResource","implements":[],"subclass":[],"variables":{"objectName":{"name":"objectName","qualifiedName":"stripe/stripe.Invoice.objectName","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"inheritedVariables":{"objectName":{"name":"objectName","qualifiedName":"stripe/stripe.Resource.objectName","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"id":{"name":"id","qualifiedName":"stripe/stripe.Invoice.id","comment":"","commentFrom":"stripe.Invoice.id","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"livemode":{"name":"livemode","qualifiedName":"stripe/stripe.Invoice.livemode","comment":"","commentFrom":"stripe.Invoice.livemode","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"amountDue":{"name":"amountDue","qualifiedName":"stripe/stripe.Invoice.amountDue","comment":"<p>Final amount due at this time for this invoice. If the invoice’s total is\nsmaller than the minimum charge amount, for example, or if there is\naccount credit that can be applied to the invoice,\nthe amount<em>due may be 0. If there is a positive starting</em>balance for the\ninvoice (the customer owes money), the amount<em>due will also take that into\naccount. The charge that gets generated for the invoice will be for the\namount specified in amount</em>due.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"attemptCount":{"name":"attemptCount","qualifiedName":"stripe/stripe.Invoice.attemptCount","comment":"<p>Number of automatic payment attempts made for this invoice.\nDoes not include manual attempts to pay the invoice.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"attempted":{"name":"attempted","qualifiedName":"stripe/stripe.Invoice.attempted","comment":"<p>Whether or not an attempt has been made to pay the invoice. An invoice is\nnot attempted until 1 hour after the invoice.created webhook, for example,\nso you might not want to display that invoice as unpaid to your users.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"closed":{"name":"closed","qualifiedName":"stripe/stripe.Invoice.closed","comment":"<p>Whether or not the invoice is still trying to collect payment. An invoice\nis closed if it’s either paid or it has been marked closed. A closed\ninvoice will no longer attempt to collect payment.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"currency":{"name":"currency","qualifiedName":"stripe/stripe.Invoice.currency","comment":"","commentFrom":"stripe.Invoice.currency","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"customer":{"name":"customer","qualifiedName":"stripe/stripe.Invoice.customer","comment":"<p>ID of the customer</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"customerExpand":{"name":"customerExpand","qualifiedName":"stripe/stripe.Invoice.customerExpand","comment":"<p><a>stripe/stripe.Customer</a> object\nThis will return null if you call retrieve without expanding.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"stripe/stripe.Customer","inner":[]}],"parameters":{},"annotations":[]},"date":{"name":"date","qualifiedName":"stripe/stripe.Invoice.date","comment":"","commentFrom":"stripe.Invoice.date","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]},"lines":{"name":"lines","qualifiedName":"stripe/stripe.Invoice.lines","comment":"<p>The individual line items that make up the invoice</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"stripe/stripe.InvoiceLineItemCollection","inner":[]}],"parameters":{},"annotations":[]},"paid":{"name":"paid","qualifiedName":"stripe/stripe.Invoice.paid","comment":"<p>Whether or not payment was successfully collected for this invoice.\nAn invoice can be paid (most commonly) with a charge or with credit from\nthe customer’s account balance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"periodEnd":{"name":"periodEnd","qualifiedName":"stripe/stripe.Invoice.periodEnd","comment":"<p>End of the usage period the invoice covers</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]},"periodStart":{"name":"periodStart","qualifiedName":"stripe/stripe.Invoice.periodStart","comment":"<p>Start of the usage period the invoice covers</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]},"startingBalance":{"name":"startingBalance","qualifiedName":"stripe/stripe.Invoice.startingBalance","comment":"<p>Starting customer balance before attempting to pay invoice. If the invoice\nhas not been attempted yet, this will be the current customer balance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"subtotal":{"name":"subtotal","qualifiedName":"stripe/stripe.Invoice.subtotal","comment":"<p>Total of all subscriptions, invoice items, and prorations on the invoice\nbefore any discount is applied</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"total":{"name":"total","qualifiedName":"stripe/stripe.Invoice.total","comment":"<p>Total after discount</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"applicationFee":{"name":"applicationFee","qualifiedName":"stripe/stripe.Invoice.applicationFee","comment":"<p>The fee in cents that will be applied to the invoice and transferred to the application owner’s Stripe account when the invoice is paid.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"charge":{"name":"charge","qualifiedName":"stripe/stripe.Invoice.charge","comment":"<p>ID of the latest charge generated for this invoice, if any.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"chargeExpand":{"name":"chargeExpand","qualifiedName":"stripe/stripe.Invoice.chargeExpand","comment":"<p><a>stripe/stripe.Charge</a> object of the latest charge generated for this invoice, if any.\nThis will return null if you call retrieve without expanding.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"stripe/stripe.Charge","inner":[]}],"parameters":{},"annotations":[]},"description":{"name":"description","qualifiedName":"stripe/stripe.Invoice.description","comment":"","commentFrom":"stripe.Invoice.description","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"discount":{"name":"discount","qualifiedName":"stripe/stripe.Invoice.discount","comment":"","commentFrom":"stripe.Invoice.discount","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"stripe/stripe.Discount","inner":[]}],"parameters":{},"annotations":[]},"endingBalance":{"name":"endingBalance","qualifiedName":"stripe/stripe.Invoice.endingBalance","comment":"<p>Ending customer balance after attempting to pay invoice.\nIf the invoice has not been attempted yet, this will be null.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"nextPaymentAttempt":{"name":"nextPaymentAttempt","qualifiedName":"stripe/stripe.Invoice.nextPaymentAttempt","comment":"","commentFrom":"stripe.Invoice.nextPaymentAttempt","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.DateTime","inner":[]}],"parameters":{},"annotations":[]},"subscription":{"name":"subscription","qualifiedName":"stripe/stripe.Invoice.subscription","comment":"<p>The subscription that this invoice was prepared for, if any.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"metadata":{"name":"metadata","qualifiedName":"stripe/stripe.Invoice.metadata","comment":"<p>A set of key/value pairs that you can attach to an invoice object.\nIt can be useful for storing additional information about the invoice in\na structured format.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{"fromMap":{"name":"fromMap","qualifiedName":"stripe/stripe.Invoice.Invoice-fromMap","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"dataMap":{"name":"dataMap","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"retrieve":{"name":"retrieve","qualifiedName":"stripe/stripe.Invoice.retrieve","comment":"<p>Retrieves the invoice with the given ID.</p>\n<p>If you need the <a>stripe/stripe.Customer</a> or <a>stripe/stripe.Charge</a> object of this invoice you can\navoid an additional API request e.g.:</p>\n<pre><code>Invoice.retrieve(id, data: {\"expand\": [\"customer\"]})\n</code></pre>\n<p>or</p>\n<pre><code>Invoice.retrieve(id, data: {\"expand\": [\"customer\", \"charge\"]})\n</code></pre>\n<p>then retrieve the <a>stripe/stripe.Customer</a> using <a>stripe/stripe.Invoice.customerExpand</a>\nOnly expand resources on demand.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"stripe/stripe.Invoice","inner":[]}]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"stripe/stripe.Invoice.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>stripe/stripe.Invoice.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"stripe/stripe.Invoice.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"stripe/stripe.Invoice.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>stripe/stripe.Invoice.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>stripe/stripe.Invoice.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"stripe/stripe.Invoice.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"stripe/stripe.Invoice.noSuchMethod","comment":"<p><a>stripe/stripe.Invoice.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>stripe/stripe.Invoice.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>stripe/stripe.Invoice.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>stripe/stripe.Invoice.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}